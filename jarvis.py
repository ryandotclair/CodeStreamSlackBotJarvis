#! /bin/python3
import os
import slack
import requests
import time
import random

@slack.RTMClient.run_on(event='message')
def jarvis(**payload):
    print("...Payload...")
    print(payload)

    data = payload['data']
    web_client = payload['web_client']
    rtm_client = payload['rtm_client']
    user_text = data.get('text', [])
    channel_id = data['channel']

#### Catches
    # If the override is set, then  force all communication from Jarvis to that channel
    if channelOverride != "default":
        channel_id = channelOverride

    # Catch if its a delete operation (or something that could throw a type error), then ignore the event.
    if type(user_text) == list:
        return

    # If message was generated by a bot, catch that.
    if "bot_id" in data:
        pass
    else:
        user = data['user']
#### This is the approval workflow
    if 'go ahead' in user_text.lower():
        executionID = os.getenv('EXECUTIONID', "default")
        print ("checking env vars")

        #Check and ensure there is something in QA to deploy, otherwise go through workflow
        if "default" in executionID:
            response = "Excuse me?"
        else:
            # Store current time, to be used to calculate how long the build lasted
            os.environ['JTIME'] = str(time.time())

            # Grab estimated time it takes to build based on historic data.
            two_hours_ago = int(round(time.time() * 1000)-7200000)
            windowtime = str(two_hours_ago)
            url = TO_BASE + "/api/v2/chart/api?n=buildtime&q=mavg(24h%2Cts(buildtime))&s=" + windowtime + "&g=s&p=1597806026415&view=METRIC&sorted=false&cached=true&useRawQK=false"

            payload = {}
            headers = {
            'Authorization': 'Bearer ' + TO_TOKEN
            }
            print ("Grabbing current estimated build time from Tanzu Observability.")
            r = requests.get(url, headers=headers, data = payload)
            rj = r.json()['timeseries'][0]['data']
            length=len(rj)-1
            estimated_deploy_time = round(rj[length][1],2)
            response = "Understood. Current estimated deployment time is " + str(estimated_deploy_time) + " seconds."

            print ("passed checks")
            print ("Grabbing Bearer Token...")

            # grab bearer token
            tPayload = '{"username":"' + username + '","password":"' + password + '"}'
            print (tPayload)
            tURL = baseURL + "/csp/gateway/am/api/login"
            print (tURL)
            Hed = {'Content-Type': 'application/json'}
            r = requests.post(tURL, data=tPayload, headers=Hed, verify=False).json()
            print (r)
            bearerToken = r["cspAuthToken"]

            # Look for the TaskID to approve, via querying the executionID
            print ("searching for the ID")

            qURL = baseURL + "/codestream/api/user-operations/?$filter=executionId%20eq%20'" + executionID + "'"
            print (qURL)
            Auth = "Bearer " + bearerToken
            Head = {'Content-Type': 'application/json', 'accept':'application/json', 'Authorization':Auth}
            r = requests.get(qURL, headers=Head, verify=False).json()
            print (r)

            # Walk the response, and grab the ID from the url in the documents.
            link = list(r["documents"])[0]
            link = link.split('/')
            TaskID = link[4]

            print ("taskID is: " + TaskID)
            print ("sending POST to approve...")

            # Send the PATCH to approve of the UserOperations Task.
            url = baseURL + '/codestream/api/user-operations/' + TaskID
            payload = '{"responseMessage": "Approved by ' + user + ' via Jarvis.","status": "Approved"}'
            r = requests.patch(url, headers=Head, data=payload, verify=False)
            print (r)

        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=response
        )
        return
#### This is the trigger for QA notification by Jarvis. Looks for subroutine's message on QA.
    if 'QA environment pending approval. Git Commit: ' in data.get('text', []) and botID in data['bot_id']:

        # Parse out the execID and git commit from the standard message (to be used later)
        msg = data.get('text', []).split(':')
        execID = msg[2].strip(' ')
        gitCommit = msg[1].strip('. ExecutionID')
        print ("Parsing Execution ID: " + execID)
        print ("Git Commit ID: " + gitCommit)

        #Store the execution ID and git commit for follow up approval workflow
        os.environ['EXECUTIONID'] = execID
        os.environ['GITCOMMIT'] = gitCommit

        #Inform notify channel of the QA environment and approval ask.
        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"Git commit " + gitCommit + " has successfully been build and deployed into QA (https://qa.example.com). Shall I push it to production?"
        )
        return

##### This is to notify production is fully deployed.
    if 'Production has been updated with git commit' in data.get('text', []) and botID in data['bot_id']:
        # This section is to update the build metric to Tanzu Observability (wavefront.com)
        # Grab current time, and pull the start time from env var
        # If the env var is blank, though, skip the TO metric step
        if os.environ.get('JTIME') == None:
            print("There wasn't a start time set, skipping buildtime metric send.")
            pass
        else:
            e_time = time.time()
            s_time = float(os.environ.get('JTIME'))
            d_time = e_time - s_time
            print ("Build time for this go around is " + str(d_time) + "seconds.")
            
            url = TO_BASE + '/report'

            payload = "buildtime " + str(d_time) + " source=jarvis"
            
            headers = {
            'Authorization': 'Bearer ' + TO_TOKEN,
            'Content-Type': 'text/plain'
            }
            print ("Sending to Tanzu Observability the buildtime...")
            response = requests.request("POST", url, headers=headers, data = payload)

            print("API call's response code is: " + str(response))
        print ("Posting successful deploy to user...")
        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"https://media.giphy.com/media/10XhRDTsVm1b4A/giphy.gif"
        )
        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"That commit is officially in production (https://example.com). Congradulations, sir."
        )
##### This is to notify user if Tanzu Observability had to roll it back.
    if 'CRITICAL: Issue with Git Commit ' in data.get('text', []) and botID in data['bot_id']:
        gitCommit = os.getenv('GITCOMMIT', "")
        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"http://www.riffsy.com/image/fcf98f4ea523b9f847202caf731328ad-2.gif"
        )
        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"I had to roll back git commit " + gitCommit + " due to higher than expected CPU usage."
        )

##### This is the Rejection workflow follow up
    if "has been rolled back due to qa rejection." in user_text.lower():
        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"I've successfully killed QA."
        )
        return

#### This is the deny workflow
    if "dear god no" in user_text.lower():
        executionID = os.getenv('EXECUTIONID', "default")
        print ("checking env vars")

        #Check and ensure there is something in QA to deploy, otherwise go through workflow
        if "default" in executionID:
            response = "Excuse me?"
        else:
            response = "That bad? Very well. Give me 60 seconds."
            print ("passed checks")
            print ("Grabbing Bearer Token...")

            # grab bearer token
            tPayload = '{"username":"' + username + '","password":"' + password + '"}'
            print (tPayload)
            tURL = baseURL + "/csp/gateway/am/api/login"
            print (tURL)
            Hed = {'Content-Type': 'application/json'}
            r = requests.post(tURL, data=tPayload, headers=Hed, verify=False).json()
            print (r)
            bearerToken = r["cspAuthToken"]

            # Look for the TaskID to reject, via querying the executionID
            print ("searching for the ID")

            qURL = baseURL + "/codestream/api/user-operations/?$filter=executionId%20eq%20'" + executionID + "'"
            Auth = "Bearer " + bearerToken
            Head = {'Content-Type': 'application/json', 'accept':'application/json', 'Authorization':Auth}
            r = requests.get(qURL, headers=Head, verify=False).json()
            print (r)

            # Walk the response, and grab the ID from the url in the documents.
            link = list(r["documents"])[0]
            link = link.split('/')
            TaskID = link[4]

            print ("taskID is: " + TaskID)
            print ("sending POST to approve...")

            # Send the PATCH to approve of the UserOperations Task.
            url = baseURL + '/codestream/api/user-operations/' + TaskID
            payload = '{"responseMessage": "Rejected by ' + user + ' via Jarvis.","status": "Rejected"}'
            r = requests.patch(url, headers=Head, data=payload, verify=False)
            print (r)

        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=response
        )
        return

#### Conversations
    if 'hello' in data.get('text', []).lower():

        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"Greetings, sir."
        )
        return

    if 'are you ready' in data.get('text', []).lower():
    
        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"I'll continue to run variations on the interface, but you should probably prepare for your guests. I'll notify you if there are any developments."
        )
        return

    if 'thanks buddy' in data.get('text', []).lower():
    
        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"Enjoy yourself, sir."
        )
        return

    if 'thank' in data.get('text', []).lower():

        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"My pleasure."
        )
        return

    if 'hello' in data.get('text', []).lower():

        web_client.chat_postMessage(
            channel=channel_id,
            as_user=True,
            text=f"Greetings, sir."
        )
        return

slackToken = os.getenv("SLACK_API_TOKEN", "default")
baseURL = os.getenv('BASE_URL_CODESTREAM', "default")
username = os.getenv('CS_USERNAME', "default")
password = os.getenv('CS_PASSWORD', "default")
channelOverride = os.getenv('JARVIS_OVERRIDE', "default")
botID = os.getenv('JARVIS_SUBROUTINE_ID', "default")
TO_TOKEN = os.getenv('TO_TOKEN', "default")
TO_BASE = os.getenv('TO_BASE', "default")

# Check that env vars are properly set
if baseURL == "default":
    print ("Please set the BASE_URL_CODESTREAM envrionment variable (ex: https://codestream_location.com)")
    exit()
if slackToken == "default":
    print ("Please set the SLACK_API_TOKEN environment variable")
    exit()
if username == "default":
    print ("Please set the CS_USERNAME environment variable")
    exit()
if password == "default":
    print ("Please set the CS_PASSWORD environment variable")
    exit()
if botID == "default":
    print ("Please set the JARVIS_SUBROUTINE_ID environment variable to the Subroutine bot's internal ID")
    exit()
if TO_TOKEN == "default":
    print ("Please set the TO_TOKEN environment variable with your Tanzu Observability API token")
if TO_BASE == "default":
    print ("Please set the TO_BASE environment variable with Tanzu Observability URL. Example: https://surf.wavefront.com")
if baseURL[len(baseURL)-1] == '/': #Check for trailing / and remove it
    baseURL= baseURL[:len(baseURL)-1]
if TO_BASE[len(baseURL)-1] == '/': #Check for trailing / and remove it
    TO_BASE= TO_BASE[:len(TO_BASE)-1]

rtm_client = slack.RTMClient(token=slackToken)
rtm_client.start()
